<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOS: mos/context.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_58b95996e735baf35348cde20760b75d.html">mos</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">context.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Contexts.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="kernel_8h_source.html">mos/kernel.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="queue_8h_source.html">mos/queue.h</a>&gt;</code><br />
<code>#include &lt;mos/trace.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for context.h:</div>
<div class="dyncontent">
<div class="center"><img src="context_8h__incl.png" border="0" usemap="#mos_2context_8h" alt=""/></div>
<map name="mos_2context_8h" id="mos_2context_8h">
<area shape="rect" id="node2" href="kernel_8h.html" title="MOS Microkernel. " alt="" coords="95,155,192,181"/>
<area shape="rect" id="node9" href="queue_8h.html" title="MOS Message Queues. " alt="" coords="163,80,260,107"/>
<area shape="rect" id="node10" href="trace_8h_source.html" title="mos/trace.h" alt="" coords="253,155,343,181"/>
<area shape="rect" id="node3" href="mos__config_8h.html" title="MOS Configuration File. " alt="" coords="5,229,105,256"/>
<area shape="rect" id="node4" href="defs_8h_source.html" title="mos/defs.h" alt="" coords="177,304,264,331"/>
<area shape="rect" id="node8" href="list_8h.html" title="Doubly&#45;Linked Circular Lists. " alt="" coords="181,229,260,256"/>
</map>
</div>
</div>
<p><a href="context_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMosContextMessage.html">MosContextMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMosClient.html">MosClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMosContext.html">MosContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMosContextTimer.html">MosContextTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0f5a5853b5404b549587f080762d82c0"><td class="memItemLeft" align="right" valign="top"><a id="a0f5a5853b5404b549587f080762d82c0"></a>
typedef u32&#160;</td><td class="memItemRight" valign="bottom"><b>MosContextMessageID</b></td></tr>
<tr class="separator:a0f5a5853b5404b549587f080762d82c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762ad564702708ead70e0b7edf9dc8f3"><td class="memItemLeft" align="right" valign="top"><a id="a762ad564702708ead70e0b7edf9dc8f3"></a>
typedef bool()&#160;</td><td class="memItemRight" valign="bottom"><b>MosClientHandler</b>(<a class="el" href="structMosContextMessage.html">MosContextMessage</a> *)</td></tr>
<tr class="separator:a762ad564702708ead70e0b7edf9dc8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf071288b0b41b19de23f4ad9be9278"><td class="memItemLeft" align="right" valign="top"><a id="abcf071288b0b41b19de23f4ad9be9278"></a>
typedef struct <a class="el" href="structMosClient.html">MosClient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MosClient</b></td></tr>
<tr class="separator:abcf071288b0b41b19de23f4ad9be9278"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a41e6609804d83834dc1a19f92e828492"><td class="memItemLeft" align="right" valign="top"><a id="a41e6609804d83834dc1a19f92e828492"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>MosContextMessageID</b> { <br />
&#160;&#160;<b>MosContextMessageID_StartClient</b> = 0xFFFFFFFC, 
<b>MosContextMessageID_StopClient</b> = 0xFFFFFFFD, 
<b>MosContextMessageID_ResumeClient</b> = 0xFFFFFFFE, 
<b>MosContextMessageID_StopContext</b> = 0xFFFFFFFF, 
<br />
&#160;&#160;<b>MosContextMessageID_FirstUserMessage</b> = 0x00000000
<br />
 }</td></tr>
<tr class="separator:a41e6609804d83834dc1a19f92e828492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96873fd8971410364f0f49b20245efc2"><td class="memItemLeft" align="right" valign="top"><a id="a96873fd8971410364f0f49b20245efc2"></a>
MOS_CLIENT_UNSAFE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosInitContext</b> (<a class="el" href="structMosContext.html">MosContext</a> *context, MosThreadPriority prio, u8 *stack_bottom, u32 stack_size, <a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg_queue_buf, u32 msg_queue_depth)</td></tr>
<tr class="separator:a96873fd8971410364f0f49b20245efc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6240b974e98bbdd2b3d56b0e5625442"><td class="memItemLeft" align="right" valign="top"><a id="ac6240b974e98bbdd2b3d56b0e5625442"></a>
MOS_CLIENT_UNSAFE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosStartContext</b> (<a class="el" href="structMosContext.html">MosContext</a> *context)</td></tr>
<tr class="separator:ac6240b974e98bbdd2b3d56b0e5625442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11f2b251810f7991bf5b2b92ec4a57f"><td class="memItemLeft" align="right" valign="top"><a id="ac11f2b251810f7991bf5b2b92ec4a57f"></a>
MOS_CLIENT_UNSAFE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosStopContext</b> (<a class="el" href="structMosContext.html">MosContext</a> *context)</td></tr>
<tr class="separator:ac11f2b251810f7991bf5b2b92ec4a57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46e2b7a2cbb13db129414450ba70b00"><td class="memItemLeft" align="right" valign="top"><a id="aa46e2b7a2cbb13db129414450ba70b00"></a>
MOS_CLIENT_UNSAFE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosWaitForContextStop</b> (<a class="el" href="structMosContext.html">MosContext</a> *context)</td></tr>
<tr class="separator:aa46e2b7a2cbb13db129414450ba70b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e9ac5ba76d2926ed6216e1389bb2b6"><td class="memItemLeft" align="right" valign="top"><a id="af3e9ac5ba76d2926ed6216e1389bb2b6"></a>
MOS_CLIENT_UNSAFE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosStartClient</b> (<a class="el" href="structMosContext.html">MosContext</a> *context, <a class="el" href="structMosClient.html">MosClient</a> *client, MosClientHandler *handler, void *priv_data)</td></tr>
<tr class="separator:af3e9ac5ba76d2926ed6216e1389bb2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b994bbd386c225198fb7a28640f56e"><td class="memItemLeft" align="right" valign="top"><a id="a86b994bbd386c225198fb7a28640f56e"></a>
MOS_CLIENT_UNSAFE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosStopClient</b> (<a class="el" href="structMosContext.html">MosContext</a> *context, <a class="el" href="structMosClient.html">MosClient</a> *client)</td></tr>
<tr class="separator:a86b994bbd386c225198fb7a28640f56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd8d3e555c9f18cca96dda0419b3f46"><td class="memItemLeft" align="right" valign="top"><a id="a6bd8d3e555c9f18cca96dda0419b3f46"></a>
MOS_ISR_SAFE MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosSetContextMessage</b> (<a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg, <a class="el" href="structMosClient.html">MosClient</a> *client, MosContextMessageID id)</td></tr>
<tr class="separator:a6bd8d3e555c9f18cca96dda0419b3f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e60f6d8855e6ec1a543bc85f408afa3"><td class="memItemLeft" align="right" valign="top"><a id="a6e60f6d8855e6ec1a543bc85f408afa3"></a>
MOS_ISR_SAFE MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosSetContextBroadcastMessage</b> (<a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg, MosContextMessageID id)</td></tr>
<tr class="separator:a6e60f6d8855e6ec1a543bc85f408afa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadf0881d123527759698865866a2b69"><td class="memItemLeft" align="right" valign="top"><a id="aeadf0881d123527759698865866a2b69"></a>
MOS_ISR_SAFE MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosSetContextMessageData</b> (<a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg, void *data)</td></tr>
<tr class="separator:aeadf0881d123527759698865866a2b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d50a51799615d42668d58ee132c91ff"><td class="memItemLeft" align="right" valign="top"><a id="a8d50a51799615d42668d58ee132c91ff"></a>
MOS_ISR_SAFE MOS_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>MosTrySendMessageToContext</b> (<a class="el" href="structMosContext.html">MosContext</a> *context, <a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg)</td></tr>
<tr class="separator:a8d50a51799615d42668d58ee132c91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8bbb14dfac4db77c431c91f8b6a4d2"><td class="memItemLeft" align="right" valign="top"><a id="abb8bbb14dfac4db77c431c91f8b6a4d2"></a>
MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosSendMessageToContext</b> (<a class="el" href="structMosContext.html">MosContext</a> *context, <a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg)</td></tr>
<tr class="separator:abb8bbb14dfac4db77c431c91f8b6a4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a25826ddaac2d265bd7c8ed47e13981"><td class="memItemLeft" align="right" valign="top"><a id="a1a25826ddaac2d265bd7c8ed47e13981"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MosInitContextTimer</b> (<a class="el" href="structMosContextTimer.html">MosContextTimer</a> *tmr, <a class="el" href="structMosContext.html">MosContext</a> *context)</td></tr>
<tr class="separator:a1a25826ddaac2d265bd7c8ed47e13981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5431ec458899ef7c0a89fa6f6561f74f"><td class="memItemLeft" align="right" valign="top"><a id="a5431ec458899ef7c0a89fa6f6561f74f"></a>
MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosSetContextTimer</b> (<a class="el" href="structMosContextTimer.html">MosContextTimer</a> *tmr, u32 ticks, <a class="el" href="structMosContextMessage.html">MosContextMessage</a> *msg)</td></tr>
<tr class="separator:a5431ec458899ef7c0a89fa6f6561f74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae38a2929592a2651c63988c54c86b7"><td class="memItemLeft" align="right" valign="top"><a id="a8ae38a2929592a2651c63988c54c86b7"></a>
MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosCancelContextTimer</b> (<a class="el" href="structMosContextTimer.html">MosContextTimer</a> *tmr)</td></tr>
<tr class="separator:a8ae38a2929592a2651c63988c54c86b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d86ac9d993f0adb3c8a93d00dc2228"><td class="memItemLeft" align="right" valign="top"><a id="a65d86ac9d993f0adb3c8a93d00dc2228"></a>
MOS_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>MosResetContextTimer</b> (<a class="el" href="structMosContextTimer.html">MosContextTimer</a> *tmr)</td></tr>
<tr class="separator:a65d86ac9d993f0adb3c8a93d00dc2228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Contexts. </p>
<p>Shared contexts allow multiple client modules to share the same resources, including a single run thread, thread stack and message queue. In addition, shared contexts can reduce or eliminate mutex contention since clients in the same shared context are guaranteed to not preempt each other. In general, shared contexts should be implemented at lower thread priorities than most other functionality. Think of contexts as a form of cooperative multitasking where memory savings are a lot more important than deadlines.</p>
<p>Contexts use a shared message queue for inter-client communication. The maximum latency depends on the maximum processing time for all messages in the context. Context clients should be implemented as state machines that multiplex received messages. Contexts can send and receive messages to or from ISRs or other threads on the system. Clients should not block or wait very long otherwise they might starve other clients sharing the same context. The MosTrySendMessageToContext() call should be used when a client sends a message to another client in the same context.</p>
<p>If a client handler has not completed and desires a callback, it should return false. Note that the callback is implemented as a resume message on the same message queue. The resume message will be added to the end of the queue allowing the opportunity for other messages to drain first.</p>
<p>Client handlers state machines should tolerate receiving messages after being <em>individually</em> stopped. This includes, but is not limited to broadcast stop messages, resume messages or potentially even user messages (depending on the system design and how the context is used).</p>
<p>The overall context will only shutdown upon receipt of a <em>broadcast</em> StopContext message and any messages that are queued beyond a <em>broadcast</em> StopContextmessage will be ignored. Any clients requesting resume after receiving a broadcast StopContext stop message will also be ignored. All clients will receive a StopClient message upon receipt of a <em>broadcast</em> StopContext message (even if already stopped). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
